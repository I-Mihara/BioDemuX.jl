var documenterSearchIndex = {"docs":
[{"location":"cli/#CLI-Usage","page":"CLI","title":"CLI Usage","text":"BioDemuX can also be used as a standalone command-line tool without installing Julia explicitly, or by building it from source.","category":"section"},{"location":"cli/#1.-Download-Pre-built-Binary","page":"CLI","title":"1. Download Pre-built Binary","text":"Go to the Releases page and download the executable for your OS (Windows, macOS, or Linux).","category":"section"},{"location":"cli/#2.-Build-from-Source","page":"CLI","title":"2. Build from Source","text":"If you want to build the executable yourself:\n\ngit clone https://github.com/I-Mihara/BioDemuX.jl.git\ncd BioDemuX.jl\njulia --project=. create_app.jl\n\nThis creates the executable at biodemux/bin/biodemux (or BioDemuX on some systems).","category":"section"},{"location":"cli/#3.-Running-the-Tool","page":"CLI","title":"3. Running the Tool","text":"[!NOTE] Julia apps may have a short startup delay (~0.5-1s) compared to C/Rust tools. To minimize this impact when processing many files, use Directory Mode (see below).","category":"section"},{"location":"cli/#Directory-Mode-(Recommended-for-Speed)","page":"CLI","title":"Directory Mode (Recommended for Speed)","text":"Pass a directory path instead of a single file to process all FASTQ files inside it efficiently (single startup).\n\nSingle-end:\n\n./biodemux fastq_dir/ barcodes.csv output_dir\n\nPaired-end:\n\n./biodemux R1_dir/ barcodes.csv output_dir --fastq2 R2_dir/\n\nNote: Files in R1_dir and R2_dir are sorted alphabetically and matched 1-to-1. Please ensure file counts and order match.","category":"section"},{"location":"cli/#Parallel-Execution","page":"CLI","title":"Parallel Execution","text":"To enable multi-threading, set the environment variable JULIA_NUM_THREADS before running.\n\nexport JULIA_NUM_THREADS=auto  # Uses all available cores\n./biodemux ...","category":"section"},{"location":"cli/#Full-Options","page":"CLI","title":"Full Options","text":"You can pass any of the configuration options as command-line arguments. Use --help to see the full list.\n\nExample with options:\n\n./biodemux input.fastq barcodes.csv output_dir \\\n    --max-error-rate 0.2 \\\n    --mismatch 1 \\\n    --summary \\\n    --gzip-output\n\nNote: Boolean flags like --summary do not require a value. Keyword arguments like max_error_rate require a value after the flag.\n\n./biodemux --help","category":"section"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#BioDemuX.BioDemuX","page":"API","title":"BioDemuX.BioDemuX","text":"BioDemuX: High-performance, flexible demultiplexing for FASTQ files.\n\nExports the main execute_demultiplexing function and configuration structures.\n\n\n\n\n\n","category":"module"},{"location":"api/#BioDemuX.AbstractScoring","page":"API","title":"BioDemuX.AbstractScoring","text":"This function aligns query to ref, using semiglobal alignment algorithm. \n\nReturns\n\nAn alignment score as a float, where lower values indicate better alignment.\n\n\n\n\n\n","category":"type"},{"location":"api/#BioDemuX.exact_align-Tuple{String, String, UnitRange{Int64}, Int64, Int64, Union{Nothing, Int64}}","page":"API","title":"BioDemuX.exact_align","text":"Aligns query to ref using exact string matching (byte-by-byte comparison). No indels or mismatches allowed. We scan query across ref_search_range in ref. Returns (0.0, start_pos, end_pos) if found, otherwise (Inf, -1, -1).\n\n\n\n\n\n","category":"method"},{"location":"api/#BioDemuX.find_best_matching_bc_no_delta-Tuple{String, Vector{String}, Vector{Int64}, BioDemuX.SemiGlobalWorkspace, Symbol, Float64, Int64, Int64, Int64, Union{Nothing, Int64}, UnitRange{Int64}, Int64, Int64, Union{Nothing, Int64}, Bool}","page":"API","title":"BioDemuX.find_best_matching_bc_no_delta","text":"Calculate and compare the similarity of a given sequence seq with the sequences in the given DataFrame bc_df.\n\nReturns\n\nA tuple (min_score_bc, min_score, delta, best_start, best_end).\n\n\n\n\n\n","category":"method"},{"location":"api/#BioDemuX.hamming_align-Tuple{String, String, Float64, UnitRange{Int64}, Int64, Int64, Union{Nothing, Int64}}","page":"API","title":"BioDemuX.hamming_align","text":"Aligns query to ref using Hamming distance. Indels are NOT allowed (distance = infinity if lengths differ in an alignment context, but here we scan). We scan query across ref_search_range in ref. N in query matches anything. N in ref matches only N in query. Returns (score, start_pos, end_pos).\n\n\n\n\n\n","category":"method"},{"location":"api/#BioDemuX.match_barcode_pass","page":"API","title":"BioDemuX.match_barcode_pass","text":"match_barcode_pass(seq::String, n::Int, config::DemuxConfig, ws::SemiGlobalWorkspace, is_pass2::Bool, stats::Union{DemuxStats,Nothing}=nothing)\n\nHelper function to run a single barcode matching pass. Returns (status, barcode_index, start_pos, end_pos). Status can be: :match, :unknown, :ambiguous.\n\n\n\n\n\n","category":"function"},{"location":"api/#BioDemuX.preprocess_bc_file-Tuple{String, Bool, Bool}","page":"API","title":"BioDemuX.preprocess_bc_file","text":"preprocess_bc_file(bc_file::String, complement::Bool, rev::Bool)\n\nPreprocesses the barcode file (FASTA or CSV/TSV). Returns a tuple: (sequences, lengths_no_N, ids).\n\n\n\n\n\n","category":"method"},{"location":"api/#BioDemuX.read_fastq-Tuple{Function, String}","page":"API","title":"BioDemuX.read_fastq","text":"read_fastq(f::Function, filepath::String)\n\nOpen a FASTQ file (potentially gzipped) for reading.\n\n\n\n\n\n","category":"method"},{"location":"api/#BioDemuX.smart_open-Tuple{Function, String, String}","page":"API","title":"BioDemuX.smart_open","text":"Helper to open files with gzip support.\n\n\n\n\n\n","category":"method"},{"location":"api/#BioDemuX.write_fastq-Tuple{Function, String}","page":"API","title":"BioDemuX.write_fastq","text":"write_fastq(f::Function, filepath::String)\n\nOpen a FASTQ file (potentially gzipped) for appending.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Dependencies","page":"Usage","title":"Dependencies","text":"Julia >= 1.10 (includes the Distributed standard library)\nJulia packages\nDataFrames >= 1.7.0\nCSV >= 0.10.14\nCodecZlib >= 0.7.0\nBufferedStreams >= 1.2.2","category":"section"},{"location":"usage/#Basic-Usage","page":"Usage","title":"Basic Usage","text":"The primary function of this package is execute_demultiplexing(). It classifies sequences in a FASTQ file by aligning them with reference barcodes in barcode file. Usage is as follows:\n\nusing BioDemuX\nexecute_demultiplexing(FASTQ_file, barcode_file, output_directory)","category":"section"},{"location":"usage/#Input","page":"Usage","title":"Input","text":"","category":"section"},{"location":"usage/#FASTQ-File","page":"Usage","title":"FASTQ File","text":"There is no restriction on the sequence length in the FASTQ file.\nThe input can be gzipped; the function automatically detects and processes the files accordingly.\nThe function can take one or two FASTQ files as input. In the case of using two FASTQ files, the command can be executed as follows:\n\nexecute_demultiplexing(FASTQ_file1, FASTQ_file2, barcode_file, output_directory)\n\nWhen using two FASTQ files, sequences in the FASTQ_file2 are classified based on the alignment of the FASTQ_file1 sequences with the barcodes in the barcode reference file. Hence, the corresponding reads in both FASTQ files must be in the same order and present in equal numbers.","category":"section"},{"location":"usage/#Barcode-Reference-File","page":"Usage","title":"Barcode Reference File","text":"The reference file is expected to be a CSV or TSV file containing the following columns: ID, Full_seq, Full_annotation, as shown below:\n\nID  Full_seq\tFull_annotation\n001-barcode ACAGACUACAAA XXXBBBBBBBXX\n\nIn the Full_seq column, the region specified as B in the Full_annotation column is considered as the barcode.\nAlternatively, a FASTA file of barcode sequences can be used as the reference. In this case, each sequence in the FASTA file is treated as a full barcode (the entire sequence is considered the barcode region) and the header line of each entry (without the > prefix) is used as its ID.","category":"section"},{"location":"usage/#Output","page":"Usage","title":"Output","text":"All output files will be saved in the specified output_directory.\nThe output is gzipped depending on the input FASTQ format, or can be specified using the gzip_output option.\nThe names of the output files are based on the filename of the FASTQ file as the prefix and the ID values in the barcode reference file. For example, if the FASTQ filename is sample.fastq and the reference file contains IDs such as 001 and 002, the resulting output files will be named sample.001.fastq, sample.002.fastq, and so on. You can freely change the prefix by specifying the output_prefix argument.\nSequences that do not match any barcode in the reference file are saved in unknown.fastq. Sequences that have ambiguous classification (i.e., they match multiple barcodes with similar scores) are saved in ambiguous_classification.fastq. These FASTQ files also have prefix like sample.unknown.fastq and sample.ambiguous_classification.fastq.\nIf the output_directory does not exist, a new directory is created to store the output files.","category":"section"},{"location":"options/#Options-and-Tips","page":"Options","title":"Options & Tips","text":"","category":"section"},{"location":"options/#Tips-to-Speed-Up-Demultiplexing","page":"Options","title":"Tips to Speed Up Demultiplexing","text":"","category":"section"},{"location":"options/#1.-Parallel-Computing","page":"Options","title":"1. Parallel Computing","text":"BioDemuX.jl supports parallel computing using multi-threading and channel-based streaming IO, allowing faster processing of large datasets with efficient memory usage. To utilize parallel processing, follow the steps below:","category":"section"},{"location":"options/#Starting-Julia-with-Multiple-Threads","page":"Options","title":"Starting Julia with Multiple Threads","text":"To enable parallel processing, you need to start Julia with multiple threads. Use the -t (or --threads) flag followed by the number of desired threads:\n\n./julia -t [number_of_threads]\n\nFor example, to use 8 threads:\n\n./julia -t 8\n\nYou can use the -t auto option to automatically detect the number of available threads and start Julia with that number of threads.\n\nYou can also set the JULIA_NUM_THREADS environment variable.\n\nexport JULIA_NUM_THREADS=8","category":"section"},{"location":"options/#Running-execute_demultiplexing-with-Parallel-Computing","page":"Options","title":"Running execute_demultiplexing with Parallel Computing","text":"Once Julia is started with multiple threads, BioDemuX.jl automatically utilizes them for reading, writing, and processing data in parallel. No additional setup is required.","category":"section"},{"location":"options/#2.-Setting-Options","page":"Options","title":"2. Setting Options","text":"BioDemuX.jl skips calculation of unnecessary path in DP matrix based on the settings of max_error_rate,mismatch. and indel. By setting lower max error rate or higher penalty, you can further increase computation speed.","category":"section"},{"location":"options/#Options-Reference","page":"Options","title":"Options Reference","text":"The execute_demultiplexing function provides several optional parameters to control the demultiplexing process:\n\nexecute_demultiplexing(FASTQ_file, barcode_file, output_directory; barcode_file2=nothing, output_prefix=\"\", gzip_output=nothing, max_error_rate=0.2, min_delta=0.0, mismatch=1, indel=1, nindel=nothing, bc_complement=false, bc_rev=false, ref_search_range=\"1:end\", barcode_start_range=\"1:end\", barcode_end_range=\"1:end\", ref_search_range2=\"1:end\", barcode_start_range2=\"1:end\", barcode_end_range2=\"1:end\", chunk_size=4000, channel_capacity=64, matching_algorithm=:semiglobal, log=false)\n\nmax_error_rate::Float64 (default: 0.2): \nThis is the maximum allowed error rate for matching sequences to barcodes. It is multiplied by the barcode's length to calculate the total penalty score that can be tolerated. If the sequence's alignment penalty exceeds this limit for all barcodes, it will be saved in unknown.fastq.\nmatching_algorithm::Symbol (default: :semiglobal):\nSpecifies the algorithm used for barcode matching.\n:semiglobal: Uses semi-global alignment allowing for mismatches, insertions, and deletions. This is the default and most robust mode.\n:hamming: Uses Hamming distance, allowing only for mismatches (no insertions or deletions). Faster than semiglobal.\n:exact: Uses exact string matching, allowing no mismatches or indels. Fastest mode. Use only when data quality is perfect or strict filtering is desired.\nmin_delta::Float64 (default: 0.0): \nThis defines the minimum difference in penalty scores needed to confidently assign a sequence to a barcode. It is multiplied by the barcode's length to determine the score difference required to avoid ambiguity. If the difference between the best match's penalty score and the second-best match's score is less than this threshold, the sequence is considered ambiguous and saved in ambiguous_classification.fastq.\nmismatch::Int (default: 1): \nThe penalty score for mismatches during sequence alignment. A higher value makes the alignment more strict for mismatches.\nindel::Int (default: 1): \nThe penalty score for insertions and deletions (indels) during sequence alignment. A higher value makes the alignment more strict for insertions or deletions.\nnindel::Union{Int, Nothing} (default: nothing):\nThe penalty score for insertions and deletions (indels) when the base is 'N' (wildcard). This should only be specified when using 'N' in barcodes or reads. Note that enabling this option may slow down the demultiplexing process.\nclassify_both::Bool (default: false): \nIf set to true, the function will classify sequences in both FASTQ_file1 and FASTQ_file2 based on the alignment with sequences in FASTQ_file1 and output separate files for each. Otherwise, it classifies only R2 sequences by default.\nbc_complement::Bool (default: false): \nIf set to true, the barcodes in the reference file are converted to their complementary sequences before alignment.\nbc_rev::Bool (default: false):\nIf set to true, the barcodes in the reference file are reversed before alignment.\noutput_prefix1::String (default: \"\"):\nSpecifies the prefix for the first set of output files when processing two FASTQ files. If not provided, the prefix defaults to the name of the FASTQ_file1. By setting this option, you can customize the file names for the first set of outputs.\noutput_prefix2::String (default: \"\"):\nSpecifies the prefix for the second set of output files when processing two FASTQ files. If not provided, the prefix defaults to the name of the FASTQ_file2. By setting this option, you can customize the file names for the second set of outputs.\noutput_prefix::String (default: \"\"):\nSpecifies the prefix for the output files when processing a single FASTQ file. If not provided, the prefix defaults to the name of the FASTQ file.\ngzip_output::Bool (default: auto-detect):\nControls whether the output FASTQ files are compressed (gzipped). By default (when this option is not explicitly set), the output will be gzipped if the input FASTQ files have a .gz extension, and uncompressed otherwise. You can set gzip_output=true to force gzipped output files or gzip_output=false to ensure output files are not compressed.\nref_search_range::String (default: \"1:end\"):\nSpecifies the range within the read sequence where the barcode search should be performed. The format is \"start:end\", where start and end can be integers (1-based index) or relative to the end of the sequence using end (e.g., \"1:20\", \"end-19:end\"). This allows you to restrict the search to a specific region, improving performance and accuracy if the barcode position is known.\nbarcode_start_range::String (default: \"1:end\"):\nSpecifies the allowed range for the start position of the barcode alignment within the read. The format is the same as ref_search_range. If the aligned barcode starts outside this range, it will not be considered a valid match.\nbarcode_end_range::String (default: \"1:end\"):\nSpecifies the allowed range for the end position of the barcode alignment within the read. The format is the same as ref_search_range. If the aligned barcode ends outside this range, it will not be considered a valid match.\nchunk_size::Int (default: 4000):\nSpecifies the number of reads to process in a single chunk. Larger chunk sizes can reduce overhead but increase memory usage.\nchannel_capacity::Int (default: 64):\nSpecifies the capacity of the input/output channels. The recycle channel capacity is automatically set to 2 * channel_capacity. Increasing this value can improve throughput on systems with high memory availability.\nbarcode_file2::Union{String, Nothing} (default: nothing):\nSpecifies the path to the second barcode reference file for dual-index demultiplexing. If provided, the function performs a two-step alignment: first against barcode_file, then against barcode_file2.\nref_search_range2::String (default: \"1:end\"):\nSpecifies the search range for the second barcode. Format is the same as ref_search_range.\nbarcode_start_range2::String (default: \"1:end\"):\nSpecifies the allowed start range for the second barcode. Format is the same as barcode_start_range.\nbarcode_end_range2::String (default: \"1:end\"):\nSpecifies the allowed end range for the second barcode. Format is the same as barcode_end_range.\nsummary::Bool (default: false):\nIf set to true, a summary report is generated after demultiplexing. The report includes statistics on total reads, matched reads, unmatched reads, ambiguous reads, and detailed distributions of alignment scores, positions, and lengths for each barcode.\nsummary_format::Symbol (default: :html):\nSpecifies the format of the summary report. Options are:\n:text: A human-readable text file (summary.txt).\n:html: An interactive HTML report (summary.html) with tabs and dropdowns for detailed visualization.\n:json: A JSON file (summary.json) for programmatic parsing.\n:stdout: Prints the summary to the standard output.\ntrim_side::Union{Int, Nothing} (default: nothing):\nSpecifies which side of the read to trim relative to the barcode.\n3: Trims the 3' side (right side) of the barcode match. Keeps the sequence before the barcode.\n5: Trims the 5' side (left side) of the barcode match. Keeps the sequence after the barcode.\nIf nothing, no trimming is performed.\ntrim_side2::Union{Int, Nothing} (default: nothing):\nSpecifies trimming for the second barcode in dual-barcode mode. Options are the same as trim_side.\nlog::Bool (default: false):\nIf set to true, basic logging information (start configuration and end duration) is printed to the standard error (stderr). ","category":"section"},{"location":"options/#Example:-How-Barcode-Length-and-Option-Values-Affect-Classification","page":"Options","title":"Example: How Barcode Length and Option Values Affect Classification","text":"We assume the case where barcode length is 10, max_error_rate is 0.2, min_delta is 0.2, mismatch is 1, indel is 2.\n\nMaximum Allowed Penalty Score:\nWith a max_error_rate of 0.2 and a barcode length of 10, the maximum allowed penalty score for a sequence to still match a barcode is 0.2 * 10 = 2.\nMinimum Allowed Penalty Difference:\nWith min_delta = 0.2 and a barcode length of 10, the minimum required difference in scores between the best and second-best barcode matches is 0.2 * 10 = 2.\nPenalty Settings:\nmismatch = 1: Each mismatch in the sequence alignment contributes a penalty of 1.\nindel = 2: Each insertion or deletion (indel) contributes a penalty of 2, making indels more costly than mismatches.\n\nWith these settings, the classification works as follows:\n\nAllowed Error:\nSince the maximum allowed penalty score is 2 (0.2 * 10):\nThe sequence can have up to 2 mismatches (since each mismatch has a penalty of 1).\nThe sequence can have up to 1 indel (since each indel has a penalty of 2).\nFor example, when the sequence have a combination of 1 mismatch and 1 indel, the penalty score is 1 (mismatch) + 2 (indel) = 3. Since this score exceeds the maximum allowed penalty score of 2, it would not be allowed.\nMatching Process:\nDuring the alignment, the sequence is compared to each barcode in the reference file. The total penalty score (based on mismatches and indels) is calculated for each alignment.\nIf a sequence's penalty score with a barcode exceeds 2, it cannot be classified under that barcode.\nAmbiguous Classification:\nIf a sequence matches multiple barcodes and the penalty scores of the best match and the second-best match differ by less than 2 (the minimum allowed penalty difference), the sequence will be classified into ambiguous_classification.fastq.\nFor example, if the best matching barcode has a penalty score of 1 and the second-best has a score of 2, the difference is 2 - 1 = 1, which is less than the threshold of 2. Therefore, the sequence is ambiguous.\nUnknown Classification:\nIf the sequence fails to match any barcode within the maximum allowed penalty score of 2, it is classified as unknown.fastq.","category":"section"},{"location":"#BioDemuX.jl","page":"Home","title":"BioDemuX.jl","text":"(Image: package_logo)\n\n(Image: Build Status) (Image: Build and Release) (Image: DOI) (Image: DOI)","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"BioDemuX.jl is a Julia package designed for demultiplexing reads based on barcodes. Given a set of sequencing reads in FASTQ format and a reference barcode in CSV or TSV format, each read is assigned to a FASTQ file corresponding to its barcode. This barcode assignment process is designed to be robust to barcode mutations and allows you to adjust the permitted level of mutation through parameters.\n\n(Image: conceptual_diagram)","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Ultara-Fast Semi-Global Alignment: Unrivaled speed with robust handling of indels and mismatches.\nExtensive Flexibility: Custom search ranges, dual barcoding, adapter trimming, and multi-mode matching (:semiglobal, :hamming, :exact).\nHigh-Performance Architecture: Multi-threaded streaming for efficient memory usage.\nVisualize Analysis: Optional interactive HTML reports.\nZero-Dependency CLI: Standalone binary for easy deployment.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"To be published.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Open the Julia REPL (by typing julia in the terminal).\nPress ] to enter the Pkg REPL mode.\nRun the following command to install BioDemuX.jl:  julia  add BioDemuX\nPress the Backspace key to exit the Pkg mode.","category":"section"},{"location":"#Dataset","page":"Home","title":"Dataset","text":"The datasets used in the paper are publicly available.\n\nIn vitro dataset and test code:\n\nLink to the dataset and test code: https://doi.org/10.24433/CO.5417078.v1\n\nIn silico dataset:\n\nLink to the dataset: https://doi.org/10.5281/zenodo.14178228","category":"section"},{"location":"#Support-or-Contact","page":"Home","title":"Support or Contact","text":"If you encounter any issues or have requests, please provide feedback by posting a new GitHub issue on our repository. We appreciate your input and will do our best to assist you!","category":"section"}]
}
